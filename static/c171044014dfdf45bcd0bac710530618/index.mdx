---
published: true
title: Skromne Monopoly
author: Paweł Stolarski
date: 2020-09-01
categories: [Gry, Projekty, Sprawozdania]
tags: [cactu, gra, monopoly, rust, react]
sneakPeek: ''
---

Zanim podejmie się pisania dużego projektu w owopoznanej sobie technologii,
warto jest (moim zdaniem oczywiście) zrobić uprzednio jakiś mniejszy twór.

W moim przypadku, dużym projektem będzie praca inżynierska.
Małym zaś, jak można się już domyślać, gra monopoly.


## Załozenia projektu


Skoro gra ta ma pełnić dla mnie rolę rozgrzewki i wstępu do programowania w języku Rust,
to powinna w sobie zawierać różne elementy uczące poruszania się po nim.
Nie może być to projekt zbyt prosty, ponieważ takowy nie nauczy mnie nic w tematach `ownership`, `borrowing`, i `lifetime`.

Postanowiłem więc zrobić **sam backend** dla gry jaką będzie coś na wzór monopoly.
Frontent zaś przygotuję z pomocą aplikacji Reacta. Skoro zaś pojawiają się pojęcia `frontu` i `backu`,
to można się łatwo domyśleć, że będzie mi potrzebna obsługa ruchu sieciowego -- takze napisanego w Ruście.

Zakładam również, że gra będzie prosta i raczej uboga. Po prostu ma być grywalna.


## Początek prac


Zacząć należy od przygotować środowiska pracy. Podejść może być pare.
W jednym podejsciu, pliki zarówno fraontu jak i backendu może być w jednym folderze.
W drugim zaś, można te środowiska rozdzielićl -- i ja uważam, ze to podejscie jest lepsze.

Jeśli prace nad gra byłyby prowadzone przez 2 zespoły, nie powinny one sobie wchodzić w drogę.
Strona clienta i serwera będą tworzone z użyciem zupełnie różnych technologii i różnymi
podejsciami do zarządzania plikami. Dodatkowo jestem zdania, że backend powinien być dla frontu
skryty za warstwą abstrakcji i tak na prawdę żadna ze stron nie powinna musieć wiedzieć jak budowana jest ta druga.
W związku z tym root projektu powinien moim zdaniem wyglądać mniej więcej tak:

```
root/
 |- backend/
 |- frontend/
  ` readme.md
```

Po utworzeniu takiej struktury, w fodlerach `backend` i `frontend` użyłem poleceń kolejno `cargo init` oraz `npx create-react-app`.
Po tej czynności otrzymałem podstawową strukturę dla obu środowisk.


```
root/
 |- backend/
 |   |- src/
 |   |- target/
 |   |- .gitignore
 |   |- Cargo.lock
 |    ` Cargo.toml
 |
 |- frontend/
 |   |- build/
 |   |- node_modules/
 |   |- publix/
 |   |- src/
 |   |- .gitignore
 |   |- package.json
 |    ` package-lock.json
 |
  ` readme.md
```

Z taką bazą można przystąpić do pisania kodu. Od czego jednak zacząć?

Tak jak z każdym projektem -- moje podejście jest takie, aby budować go od ogółu do szczegółu.
Co w pierwszej kolejności powinienem mieć, aby robić cokolwiek więcej?
Jak projekt zostanie przedstawiony użytkownikowi? na czym cały projekt będzie się opierać?
W przypadku tworzonego monopoly, jest to strona internetowa.
To na niej będzie opierać się cały twór.

Jednak wpisanie `npm start` to w zasadzie nic. Aplikacja Reacta sama stworzy serwer
i otworzy stronę w przeglaarce. Aby podejść do sprawy sensownie,
to samodzielnie napisany serwer powinien serwować pliki. Pliki -- właśnie -- jakie.
Jako, ze projekt opiera sie na Reakcie, to hostowane pliki najprościej będzie znaleźć w folderze `frontend/build/`.
Majac to na uwadze, zamiast startować aplikację, lepiej będzie użyć `npm build`.

Kolej nadeszła na rozważania nad serwerem. W tym przypadku, backend ma być jednolity -- nie rozbudowwywalny.
Piszac to mam na myśli to, że ma stanowić jeden zwarty produkt. Nie ma być częścią czegoś innego.
Nie ma pełnić rolę modułu dla innego projektu. Dodatkowo warto zauważyć, że serwer będzie pełnić funkcję całej aplikacji.
To serwer wyśle plik strony którą zinterpretuje przegladarka, to serwer przechwyci rządanie aktualizacji protokołu do WebSocket,
oraz to serwer będzie odbierać i odpowiadać na eventy ws.

Czego by nie zrobić po stronie clienta, to serwer będzie tym zarządzać. Pomysł mam więc taki:
w pliku `main.rs`, (czyli głównym pliku backendu) zaciagnać 2 rustowe moduły
(bo tak wygląda dołączanie innych plików, po prsotu są to moduły) odpowiedzlane za serwer, oraz za grę.
Oba te moduły zintegruje się w "mainie" tworząc strukturę serwera, przekazujac jej handler zdarzeń ws gry, oraz właczajac serwer.

~~Zdaje sobie sprawę z tego, ze dużo razy użyłem słowa `serwer`.~~

Frontend z kolei ma pełnić jedynie funkcje interpretacyjne tego co dostał z serwera.
Nie może być po stronie clienta zawarta żadna logika która moze wpłynąć na serwer.
Client powinien móc jedynie wysyłać sygnały że podjął jakieś działania.

<Aside>
  Oczywiście jest to spore uproszczenie. Client co prawda nie powinien wykonywac logiki,
  która wpłwyałaby na serwer, lecz powinien wykopnywać logikę wpływajacą na samego siebie.
  Jest to bardzo pomocne przy pracy z interfejsami sieciowymi. Umożliwia eliminację lagów.
</Aside>

Do rysowania planszy najprościej będzie wykorzystać "nołdowe" (node-owe(?)) moduły `react-three-fiber` oraz `drei`.
Moduły te dostarczają kolejnej niesamowitej warstwy abstrakcji do abstrakcji dostarczanej przez three.js,
które z kolei dostarcza jej dla WebGL dostarczajacego abstrakcji wywołaniom systemowym dosta... starczy tego.
Ważne, ze mozna w tej technologii napisać krótki robiący sporo kod dajacy w rezultacie całkiem wydajną aplikację.

Warto nadmienić, że pomysł z organizacją serwera i clienta można przedstawić w modelu MVC.
Na serwerze nie jest prostym mówić o `widoku`, lecz załóżmy, że jest to sposób używania modułów w mainie.
Kontrolerami będą główna struktura serwera oraz gry. Oba one przyjmują informacje i zarządzają modelami,
którymi są mp. "handler" socketów oraz plansza gry.
Po stronie clienta zaś komponentem widoku będzie między innymi plik `App.js` definiujący szkielet i styl aplikacji.
Kontrolerem naznaczony zostanie plik `Game.js` ponieważ odpowiedzialny będzie za przechwytywanie zdarzeń wszelakiego typu,
a za model będzie odpowiadać przykładowo `Tile.js` odpowiedzialny za kafelek gry.

<Info>
  Dalszą część wpisu będe kontynuować w czasie przeszłym --
  uznaj, że tekst do tego momentu był wstępem organizacyjnym pisanym przed przystąpieniem do pracy
  a jego dalsze części zostały napisane juz po fakcie.
</Info>


## To samo słodkie, czyli tworzenie -- ale w skrócie


Znalezienie lekkiej i dobrze działajacej biblioteki/frameworka dla ruchu http+ws nie jest proste.
Biblioteki głównie obsługują tylko jeden z tych ruchów sieciowych.
Tak dla przykładu [hyper](https://docs.rs/hyper/0.13.7/hyper/) obsługuje ruch http,
lecz taki [ws](https://docs.rs/ws/0.9.1/ws/) jak anzwa wskazuje potrafi zapanowac tylko nad websocketami.
Znalezione rozwiązanie? Użyć `hyper` wraz z [tokio_tungstenite](https://docs.rs/tokio-tungstenite/0.11.0/tokio_tungstenite/).
Dodatkowo (jak z nazwy tego drugiego wynika) trzeba zaciagnać [tokio](https://docs.rs/tokio/0.2.22/tokio/), lecz to nie problem -- nawet wskazane.
Skoro tokio, to także [futures](https://docs.rs/futures/0.3.5/futures/).
Jako, że do stworzenia aktualizacji protokołu potrzebne są szyfrowanie [sha-1](https://docs.rs/sha-1/0.9.1/sha1/)
oraz kodowanie [bash64](https://docs.rs/base64/0.12.3/base64/) to je takze nalezało zaciągnać z sieci.

Dysponujac tymi trzeba paczkami stworzyłem serwer http+ws pisząc aktualizację protokołu jak i przechowywanie socketów samodzielnie.
Ciekawa rzecz, chciałem się tego nauczyć lecz bez jakiegoś duzego ciśnienia i teraz miałem okazję to zrobić.
W celu zrobienia tego poprawnie przydatnym źródłem okazał się [MDN](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers).

![BARDZO długa lista typów MIME](./mime_types.png)

Jednakowoż na początku nie zaimplementowałem rozgłąszania broadcast. Jest ono na tyle nietypowym przypadkiem,
że poza samym socketem wymaga dostępu do wszystkich innych. Tak więc sam socket powinien mieć jakiś
bez- lub pośredni dostęp do wektora wszystkich innych socketów.

Zabrałem się więc do frontu. W pierwszej kolejnosci poszło `npm i three.js react-three.fiber drei`.
W zasadzie front nie jest niczym nadzwyczajnym. Od zależało mi na wyświetlaniu elementów na ekranie.
Najważniejszym jednak był dla mnie kontroler WebSocket -- chiałem aby działał podobnie co [socket.io](https://socket.io/)

```js
componentDidMount() {
  this.ws.on( `founded game`, data => {
  this.ws.on( `board update`, data => {
  this.ws.on( `move`, data => {

  this.ws.emit( `searchGame`, { square:9 } )
  setInterval( () => this.ws.emit( `move`, this.player?.boardId ), 1000 )

  window.game = this
}
```

Co prawda teraz przy wpisywaniu powyższego listingu pomyślałem o tym aby wpisaćna poczatku metody
`const { ws } = this` albo aby metody `ws` zwracały swój kontekst
aby można było łańcuchowo izywać kolejnych metod. Cóż, moze później

![Wynik tego, co udało mi się zrobić na froncie](./plansza.png)

Mając planszę kolej przyszła na graczy -- skaczące prostopadłościany.
Zrobienie jednego gracza to bułka z masłem -- informacja do serwera, że chcę skoczyć,
"rzut kością" i wysolosowanie nowej pozycji, `socket.emit` do clienta, i ustawienie pozycji. Łatwe.

Problem jednak zaczął się przy komunikacji większej ilości graczy.
To jest moment który mnie zdemotywował do dalszego działania.
Ktoś mógłby powiedzieć "No przecieć to to samoc o dla jednego, tylko że dla wielu".
W skrócie tak, to prawda. Tak na prawdę obsługa wielu graczy różniłaby się od wersji z pojedynczym graczem tym,
że wiadomość o skoku konkretnego gracza należałoby "broadcastować".

Problem w tym, że zrobienie tego nie jest takie oczywiste. Koncepcyjnie to serwer powinien móc
wysyłać wiadomości do socketów. W zwiazku z tym, jako że broadcast nomen omen musi komunikować się ze wszystkimi,
to umieszczenie metody `broadcast` w strukturze (albo rustowo -- w cesze(?)) kontrolera WebSocket jest racjonalne.
Co dalej, cóż. Programista JSa dałby zwykłą referencję w sockecie do tejze metody. W C++ dałoby radę wskaźnikiem.
Tutaj, cóż. Nie chcę używać `unsafe` kodu, więc pominę takie elementy.

W pierwszym podejściu wydzueliłem `receiver` ze struktury socketa i bezpośrednio jego wrzuciłem w loop obsługi zdarzeń.
Zrobiłem to dlatego, ponieważ w czasie broadcastowania iterowanie po wszystkich socketach i ich `lock`owanie
bardzo szybko doprowadzało do [zatrzasku (deadlocka)](https://pl.wikipedia.org/wiki/Zakleszczenie) gdy odbiorca był w strukturze.
Prosze sobie wyobrazić:
 1. Na serwerze znajdują się 2 sockety;
 2. Oba są stale używane przez swój wątek, ponieważ nasłuchują zdarzenia;
 3. Jeden z nich chce nadać wiadomość broadcast, więc musi przechwycić `sender` drugiego;
 4. Operacja kończy się zakleszczeniem, ponieważ drugi nigdy nie odda socketu, a pierwszy nie odpuści oczekiwania.

```rs
let socket_mutex = Arc::new( Mutex::new( Socket::new( ws_stream, broadcast_adapter ) ) );
let mut socket = socket_mutex.lock().await;

loop {
  let msg = socket.wait_for_message().await;

  ...
```

```rs
let (sink, mut stream) = ws_stream.split();
let socket_mutex = Arc::new( Mutex::new( Socket::new( sink, broadcast_adapter ) ) );

loop {
  let msg = stream.next().await.unwrap().unwrap();
  let mut socket = socket_mutex.lock().await;

  ...
```

Wydzielając odbiorcę ze struktury socketu wyeliminowałem ten problem, lecz szybko pojawił się następny.
Nikt nie ma wpływu na to, kiedy (lekko upraszczając) procesor uzna, że czas pracy wątku się skończył
i kolej jest na następny. W związku z tym doszło do sytuacji przedstawionej na screenie poniżej:

![Przykłąd zakleszczenia. Jeden kolor = działania jednego socketa](./zakleszczenie.png)

Normalnie powinien tam wystąpić jeszcze log `end of lock <id>` lecz nie wystąpił.
W tym przypadku deadlock pojawił się w podobnej sytuacji co przed zmianami --
po zablokowaniu dostępu do obu socketów i próbie wzajemnego dostępu do siebie.

<audio controls src="./przykra_sprawa.mp3" />








Jako, że jest to mój projekt rozgrzewkowy do srodowiska, to oczywiście nie wiem czy moje rozwiązanie jest słuszne,
lecz projektowo uznałem,


Sama gra raczej nie została przemyślana bardzo dobrze. Ot **po prostu miała działać**.
Dlatego też nie pokusiłem się o najlepsze wzorce, przykładowo [memoizacji](https://en.wikipedia.org/wiki/Memoization)(?)


Nie wykluczam późniejszej dalszej aktualizacji tego kodu, ponieważ myślę, ze może się on komuś przydać.
Skoro mi się nie udało znaleźć dobrego serwera http+ws i stworzyłem go samemu, to moze ktoś także będzie poszukiwac i tym razem znajdzie ^^.
Przy czym zaznaczam, że kod ten wymaga sporo poprawek/usprawnień aby móc z niego swobodnie korzysać. Chociaż może pomogłaby społeczność githuba...