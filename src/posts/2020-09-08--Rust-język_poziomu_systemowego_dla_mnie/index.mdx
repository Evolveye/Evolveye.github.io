---
published: false
title: Rust -- język poziomu systemowego w moim guście
author: Paweł Stolarski
date: 2020-09-08 16:00:00
categories: [Rozmaitości]
tags: [języki komputerowe, rust, react]
sneakPeek: '
  Jako że "leniwy programista to dobry programista", to lubuję się w językach cechujących się pewną prostotą i przemyślanym podejsciem.
  Z tej przyczyny przysiadłem przy JSie jak i od zawsze odrzucałem nieprzyjemnego dla mnie C++.
  Po kilku latach programistycznej praktyki drugi juz raz spojrzałem na Rusta i cóż -- wpasował się.
'
---

Kilka lat temu za czasów technikum, kolega z klasy zaczepił mnie i zapytał czy słyszałem o takim śmiesznym języku rdzy,
tj Ruście (albo Raście, wiadomo o co chodzi). Na tamten czas jednak w zasadzie poza przeglądarką mało co mnie interesowało więc odpowiedziałem że nie
i wspólnie jako nastoletni specjaliści zaczęliśmy śmieszki ze składni wspomnianego języka.

Teraz jednak (a w zasadzie na początku tegoż dziwnego roku 2020) gdy rozpocząłem czytanie [tutorialo-dokumentacji](https://doc.rust-lang.org/book/)
stałem się wielkim fanem tego języka. Samo czytanie tej "książki" było dla mnie przyjemnością a odkrywanie kolejnych elementów języka
i tego dlaczego są one napisane tak a nie inaczej przyprawiało mnie o zdumienie.

## Dlaczego Rust

Zanim powstał Rust, niepokonanym królem był C++ (królem wydajnościowym przy obiektowym, zrozumiałym wydaniu).
Jako że ja poznałem C++ po wielu latach od jego wydania, i po tym gdy znałem (po prostu znałem; niekoniecznie dobrze)
już takie języki jak chociażby JS, python, Java, SQL, to taki C++ wydawał mi się dobitnie zaznaczać swoją starość.
Dla mnie, język ten jest nieprzyjemny ponieważ trzeba zadbać o wiele rzeczy które inne języki (czy też ich środowisko) robią samodzielnie. Tak dla przykładu:
 * [przepełnienie bufora](https://en.wikipedia.org/wiki/Buffer_overflow) ([pl](https://pl.wikipedia.org/wiki/Przepełnienie_bufora))
 * [wycieki pamięci](https://en.wikipedia.org/wiki/Memory_leak) ([pl](https://pl.wikipedia.org/wiki/Wyciek_pamięci)) -- brak garbage collectora :kot:
 * [podwójna dealokacja](https://stackoverflow.com/questions/21057393/what-does-double-free-mean) (znalazłem tylko z angielska)
 * [naruszenie bezpieczeństwa pamięci](https://en.wikipedia.org/wiki/Segmentation_fault) ([pl](https://pl.wikipedia.org/wiki/Naruszenie_ochrony_pamięci)) -- np. odwołanie do nulla

Do powyższej listy dodałbym także składnię (nie jest kwestią bezpieczeństwa, stąd umieszczam poza listą),
która wygląda jak połatany różnymi materiałami element ubioru -- jakby bez namyślunku (który tam oczywiscie jest, a zywczjanie do mnie nie przemawia)

W kontrze (jak sie tego można było spodziewać) staje Rust. Tak jak C++ jest to *[system programming language](https://en.wikipedia.org/wiki/System_programming_language)*,
czyli w skrócie jest to język wydajny o dużych możliwosciach. Każdy z przytoczonych problemów rozwiązuje już w czasie kompilacji.
Wielkim atutem Rusta jest odpowiednik znanych garbage collectorów -- `ownership`, czyli własność(?)/przynależność(?).
Zbieracz nieużytków jest takim elementem środowiska, który co jakis czas skanuje pamięć i wyrzuca z niej "śmieci",
czyli zwalnia nieużywane już miejsca pamięci. System przynależności w Ruście eliminuje potrzebę "skanowania" pamięci.
Każdy element języka, który należy przechowywać w pamięci posiada swój włąsny czas życia (lifetime).
Każde takie pole jest przypisane do jakiegoś posiadacza. Każda klamra zamykajaca blok kodyu ma zdolność
do wywoływania funkcji `drop` na danych których przestrzeń użytkowa dobiega końca.
Gdy są one kasowane, wszystkie posiadane dane również powinny zostac usunięte. Tak to w uproszczeniu by działało.
Aby podsycić ciekawość dodam, ze jest to język obiektowy a nie posiada klas :O, nulli :O, ani bloku try/catch :O.

Dlaczego w ogóle mi On potrzebny? Cóż, poza wysoce abstrakcyjnym JavaScriptem chcę znać też język poziomu systemowego.
Gdybym chciał napisać program stawiajac na wydajność, to użyłbym właśnie takiego języka.
Oczywiście, ktoś mógły podnieść głos, że Node.js jest przecież wydajny więc o co mi chodzi.
Posłużę się tu grafiką przedstawiajacą wydajności różnych bibliotek obsługujących ruch sieciowy:
![Średnio aktualne porównanie wydajności Node.js w stosunku do innych środowisk](./uWS.png)

<Note>Dane te są od dawna nieaktualne, a zamieszczam je tu jedynie poglądowo.</Note>

Na powyższej grafice `WS (Node.js)` jest bliski temu ile można wycisnąć z samego Node. Nie jest to zbyt szybko.
Czy Byłoby sensowne aby za pomocą JSa renderować grafikę trójwymiarową
w 60 klatkach na sekundę na Twoim własnym osobistym komputerze? Moim zdaniem nie.

Dodatkowo wydaje mi się, ze mozę to być język który będzie tylko zyskiwać.
Nie jednokroć pojawiały się głosy o [przepisaniu części Windowsa na Rusta](https://msrc-blog.microsoft.com/2019/11/07/using-rust-in-windows/),
czy o powstajacym [Deno pisanym w ruscie](https://deno.land/).
Wiecej, można przeczytać pod pierwszym znalezionym linkiem z google, [team queście](https://teamquest.pl/blog/1376_czy-rust-to-nowe-c)

## Plany

Na moment pisania tego tekstu w planach mam robienie w Ruscie backendu dla gier multiplayer,
oraz zrobienie pracy inżynierskiej. Tak wyjdzie, czas pokaże.

Gdybyś chciał poczytać wiecej o Ruscie, a [książka](https://doc.rust-lang.org/book/) CI nie odpowiada -- pisz śmiało.